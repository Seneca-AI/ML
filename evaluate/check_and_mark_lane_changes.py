"""
sample CLI
python3 check_and_mark_lane_changes.py \
    --source_binary_images ./binary_results2 \
    --csv_destination ../extras/Image_names_and_lane_change_status_vid_2.csv
Cropping the images and looking for lanes
"""

import argparse
import glob
import warnings

import cv2 # pylint: disable=import-error
import numpy as np # pylint: disable=import-error
import pandas as pd # pylint: disable=import-error

def init_args():
    """
    Initialize command line arguments.
    """
    parser = argparse.ArgumentParser()
    parser.add_argument(
        '--source_binary_images',
        type=str,
        default = "./binary_results2",
        help='The path to the input dataset for second type of dataset'
    )
    parser.add_argument(
        '--csv_destination',
        type=str,
        default= '../extras/Image_names_and_lane_change_status_vid_2.csv',
        help='path to where you wish to save the frames for the output of second type of dataset'
    )
    return parser.parse_args()

def check_and_mark_lane_changes(source_binary, csv_destination):
    """
    This function reads a directory of images, evaluates each image on whether
    or not the driver is in the middle of a lane change by checking if the lane
    line is within a bounded box, and stores the output (1 = changing_lanes, 0 = !changing_lanes)
    in a CSV file against name of every frame.

    Parameters
    ----------
    source_binary string: Path to binary files
        (generated by the code evaluate_vid_on_lanenet.py).
    csv_destination string: Name and location of the csv output folder.

    Returns
    -------
    None
    """
    names = []
    lane_change = []
    for i in sorted(glob.glob(source_binary)):
        img = cv2.imread(i,0)
        if len(np.unique(img)) < 30:
            pass
        else:
            warnings.warn("Given image may not be binary image -- pixels > 30")
        if img is None:
            raise ValueError("The given directory of the binary images may not be correct.")
        size = (512,256)
        img = cv2.resize(img, size, interpolation = cv2.INTER_AREA)

        # from experimentation these are the values of the Bounding Box
        # Any value of the lane inside the Bounding Box is taken as an instance of lane change
        left_bound = int(img.shape[1]*1/4)+2
        right_bound = int(img.shape[1]*3/4)
        bottom_bound = 211 #pixel value from experimentation
        top_bound = len(img)

        cropped_area = img[bottom_bound:top_bound,left_bound:right_bound]
        unique_array = np.unique(cropped_area)
        lane_values = [250,251,252,253,254,255] # values of the lane given by laneNet
        existing = np.isin(lane_values, unique_array)
        name = i.split("/")[-1]

        lane_change_found = 0
        for j in existing:
            if j:
                lane_change_found = 1
                break
        names.append(name)
        lane_change.append(lane_change_found)
    csv_dict = {'name_of_img': names, 'lane change (0/1)': lane_change}
    dataframe = pd.DataFrame(csv_dict)

    # saving the dataframe
    dataframe.to_csv(csv_destination)

if __name__ == '__main__':
    args = init_args()
    check_and_mark_lane_changes(
        source_binary = args.source_binary_images,
        csv_destination= args.csv_destination
    )

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Wed Feb 24 20:50:40 2021
Cropping the images and looking for lanes
@author: sagar
"""


import cv2
import numpy as np
import matplotlib.pyplot as plt
import glob
import pandas as pd
import argparse
def init_args():
    """
    for the CLI
    :return:
        arguments
    """
    parser = argparse.ArgumentParser()
    parser.add_argument('--source_binary_images', type=str, default = "/media/sagar/New Volume/everything/job/Seneca/data/making_vid/binary_results2/*",help='The path to the input dataset for second type of dataset')
    parser.add_argument('--CSV_destination', type=str, default= './Image_names_and_lane_change_status_vid_2.csv',help='path to where you wish to save the frames for the output of second type of dataset')
    return parser.parse_args()

def check_and_mark_lane_changes(source_binary, CSV_destination):
    """
    This function is used for checking all the instances of lane changes and put them all in a csv
    file with a 1 against the frame names and 0 against the case where we dont have instance of lane change
    

    Parameters
    ----------
    source_binary : str
        DESCRIPTION. Give the location of the binary files(generated by the code evaluate_vid_on_lanenet.py) as the location
    CSV_destination : csv file
        DESCRIPTION. Give the name of the csv folder. 

    Returns
    -------
    df : dataframe
        DESCRIPTION. Prints the dataframe

    """
    names = []
    lane_change = []
    for i in sorted(glob.glob(source_binary)):
        s = 0
        img = cv2.imread(i,0)
        img = cv2.resize(img, (512,257), interpolation = cv2.INTER_AREA)
        X1 = int(img.shape[1]*1/4)+2
        X2 = int(img.shape[1]*3/4)
        Y1 = 211
        Y2 = len(img)
        cropped_area = img[Y1:Y2,X1:X2]
        unique_array = np.unique(cropped_area)
        element = [250,251,252,253,254,255]
        existing = np.isin(element, unique_array)
        print(i)
        name = i.split("/")[-1]
        for j in existing:
            #print(i)
            
            if j == True:
                s = 1
                break
            elif j == False:
                #s = 0
                continue
        names.append(name)
        lane_change.append(s)
        #break
    dict = {'name_of_img': names, 'lane change (0/1)': lane_change}   
       
    df = pd.DataFrame(dict)  
        
    # saving the dataframe  
    df.to_csv(CSV_destination)  
    print(df)
    return df
#%% test code
if __name__ == '__main__':
    source_binary = "/media/sagar/New Volume/everything/job/Seneca/data/making_vid/binary_results2/*"
    CSV_destination = './Image_names_and_lane_change_status_vid_2.csv'
    check_and_mark_lane_changes(source_binary, CSV_destination)